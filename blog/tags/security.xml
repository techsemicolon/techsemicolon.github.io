<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Tech.Semicolon]]></title>
    <link href="https://techsemicolon.github.io/blog/tags/security.xml" rel="self"/>
    <link href="https://techsemicolon.github.io/"/>
    <updated>2019-04-24T11:25:14+00:00</updated>
    <id>https://techsemicolon.github.io/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Laravel tips for a secure healthcare application]]></title>
            <link href="https://techsemicolon.github.io/blog/2019/03/25/laravel-tips-for-a-secure-healthcare-application/"/>
            <updated>2019-03-25T00:00:00+00:00</updated>
            <id>https://techsemicolon.github.io/blog/2019/03/25/laravel-tips-for-a-secure-healthcare-application/</id>
            <content type="html"><![CDATA[<p>Laravel being a very flexible framework, it can be a great choice for building large applications in domains which require higher levels of application security. Some of such domains are Healthcare, Banking, Government, Ecommerce. Any website no matter what is the domain, needs to be secure. However, with the beforementioned domains, liabilities are much more because you are dealing with very sensitive data.</p>

<p>Security breaches can occure from many ways, not just from application's development vulnerabilities but some of the architecture level server backdoors or may be poor levels of access control. We will be just discussing the steps you can take on Laravel framework level to make sure there are no such loopholes or backdoors open for exploitation.</p>

<h3 id="1.-authentication-and-acl-%3A">1. Authentication and ACL :</h3>

<p>Let's get the basic definition of authentication first, <code>Its the process of verifying the identity of a user</code>. Authentication process is a key entry point using which user in your application logs in. It can be stateful which maintains a user session on server and client level or stateless/token based authentication. All the secure domains MUST have extremely robust and full proof authentication set up.</p>

<p>Below are some of the pointers you SHOULD consider : 
- Get minimum information about the user but make sure its verified/authentic. Earlier email verification was a key. Now a days there are so many disposable email services available or simply creating a new fake gmail account is not much of a pain, its no more a safe way to verify. You can use more personalized way of verification which is from user's mobile number.
- Log the user's IP address and access geolocation. This will give you a couple of locations from which user frequently accesses the application login. If someone logs in from a different/new location, you can shoot an email or text message for an approval. This is extremely handy as if user denies that its not him/her, you can immediately block that user automatically until some futher unblock action is taken from the original user.
- If your website allows passwords like <code>test123</code> or <code>abcd1234</code> or <code>qwerty</code>, it is a high time you need to go back and update that without thinking twice. You SHOULD enforce password strength policies.
- Make sure you are not fooling around with the default password hashing in Laravel. If you do, make sure its a very strong authentication which is NOT reversible. The thumb rule is <code>Implement a cryptography which is a one way function which means that you can convert your password to a hash, but you can not easily convert your hash to a password</code>.
- Enable throttling and if you see the large consecutive failed attempts, log it and report it to the user. Lock the user until he verifies its him/her.
- If you are having username as the main login reference instead of email, do not override entire login functionality in Laravel. Laravel provides a handy way to do the same. 
- If you are using one time passwords(OTP) for any set of login authentication, make sure those are unique and enabled for limited duration with an expory time. Also, the route urls in which user enters the OTP can be a temporary signed url with an expiration time as well.
- There should be NO admin with all access. The main misconception is, if there is an owner/higher level person, he/she has to have a login to see all information. There has to be a limit on what the higher level people see.
- This can be a totally big topic of discussion, but I do not see a point of having 3rd party social logins in a secure website. You have to have total control over the authentication process. If I am logging through google, you know how easy it is to have a face gmail account.
- STOP integrating 3rd party plugin directly into authentication unless you study them entirely, view issues threads or may be contact the developers for more details infomation on how their plugin is maintaining basic security. The last think you would want is, having your application secured but a 3rd party plugin you installed has a backdoor for exploitation.
- 
- Even if your website has just few sets of user types, set role for each user.
-</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Laravel restricting unfiltered queries]]></title>
            <link href="https://techsemicolon.github.io/blog/2019/01/04/laravel-restricting-unfiltered-queries/"/>
            <updated>2019-01-04T00:00:00+00:00</updated>
            <id>https://techsemicolon.github.io/blog/2019/01/04/laravel-restricting-unfiltered-queries/</id>
            <content type="html"><![CDATA[<p>Laravel eloquent is a very powerful ORM. I came across a situation for a project of mine long time ago. There was a table <code>api_logs</code> which basically logged all API requests and responses. Evidently the table grew exponentially. One of the developers created an analytics module in which he forgot to add a where clause. It queried millions of rows at a time on production. It was a silly mistake but server was overwhelmed and you can imagine the rest of story (I can tell you it is not that good).</p>

<p>I imagined if there was a way to just throw an error if any function queries all rows from a table like <code>api_logs</code>. Two advantages :</p>

<ul>
<li>Error will be thrown during the development cycle where it's like an eye opener for the developer to make sure he adds filters.</li>
<li>If the develolper pushed the code to live by mistake, someone requesting the page will get the error page. I will be still having advantage with x% of customers getting an error rather than 100% of customer not using website when memory is exhausted. (If that query was in the header or footer on every page then basically it's over haha!)</li>
</ul>

<h4 id="implementation-%3A">Implementation :</h4>

<p>Short and simple, nothing fancy. We will just intercept an eloquent model for every query and check if it has a where clause. The best place for that is <code>boot</code> method of the model. I wish laravel has <code>retreiving</code> observer just like <code>created</code>, <code>updated</code> etc, which intercepts the query before it hits the database connection. (I am guessing as observers basically observes the state of a model instance, the state prior to <code>retreiving</code> is ideally an inception step of preparing collection of models/model and not yet a prime state to observe. And hence no such observer yet available.)</p>

<p>We can however use <code>\DB::listen()</code> listener as follows :</p>

<pre><code class="php">&lt;?php

namespace App\Model;

use Illuminate\Database\Eloquent\Model;

class ApiLog extends Model
{
    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'api_logs';


    /**
     * The "booting" method of the model.
     *
     * @return void
     */
    public static function boot(){

        parent::boot();

        \DB::listen(function($query) {
            //
        }); 
    }
}
</code></pre>

<p>Note that for Laravel version <code>5.1</code> and lower, the parameters of listen callback are <code>$sql, $bindings, $time</code> instead of just <code>$query</code>;</p>

<p>Now we have an listener, we need to get the query and check if it is selecting all rows. We will do it by regex on the raw sql.</p>

<pre><code class="php">&lt;?php

    \DB::listen(function($query) {

        $table = (new self)-&gt;table;
        $pattern = "/from(\s)*?`?$table`?(\s)*$/m";

        if(preg_match($pattern, $query-&gt;sql)){
            throw new \Exception("Error : Running unfiltered queries on `$table` table is not allowed!");
        }
    }); 
}
</code></pre>

<p>Above preg match will catch all queries which do not have any clauses after the table syntax. Those can be select, update or delete queries.</p>

<p>Let's make this little more manageable by creating a trait and then using it in model. Create <code>RestrictsUnfilteredQueries.php</code> :</p>

<pre><code class="php">&lt;?php 

namespace App\Model;

trait RestrictsUnfilteredQueries
{
    /**
     * Restrict unfiltered queries
     * 
     * @return void
     * @throws \Exception
     */
    public static function restrictUnfilteredQueries()
    {
        \DB::listen(function($query) {

            $table = (new self)-&gt;table;
            $pattern = "/from(\s)*?`?$table`?(\s)*$/m";

            if(preg_match($pattern, $query-&gt;sql)){
                throw new \Exception("Error : Running unfiltered queries on `$table` table is not allowed!");
            }
        }); 
    }
}
</code></pre>

<p>Using in the model's boot method :</p>

<pre><code class="php">&lt;?php

namespace App\Model;

use Illuminate\Database\Eloquent\Model;
use App\Model\RestrictsUnfilteredQueries;

class ApiLog extends Model
{
    use RestrictsUnfilteredQueries;

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'api_logs';


    /**
     * The "booting" method of the model.
     *
     * @return void
     */
    public static function boot(){

        parent::boot();

        self::restrictUnfilteredQueries(); 
    }
}
</code></pre>

<p>And done! Now your server RAM will thank you forever for this ;)</p>

<p>Note that this will not work when you query using DB facade like <code>DB::select()</code> or <code>DB::table()-&gt;get()</code>.</p>

<p>You may alternatively cater this as well by having <code>DB::listen()</code> inside a service provider's boot method. It will listen to all sort of queries. However, it might be too much to listen all queries.</p>

<p>There might be better way of implementing the same, I did it this way considering the urgency of situation. It is still there in project since then and working perfectly.</p>
]]></content>
        </entry>
    </feed>